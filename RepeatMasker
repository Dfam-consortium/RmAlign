#!/usr/bin/env python3
"""
RepeatMasker

  This is a wrapper for the Nextflow RepeatMasker pipeline.  This is
  a convenience script to normalize to create a familiar interface to
  the pipeline.

  Basic functionality:
  - Minimal environment checks for Nextflow and Java versions
  - Creates project_dir if it doesn't already exist
  - Changes into the project_dir so that Nextflow logs/work are placed there
  - Invokes Nextflow
  - Forwards unknown args to Nextflow unchanged
"""

import argparse
import os
import re
import sys
import subprocess
from pathlib import Path
from typing import List, Tuple, Optional

# TODO: Move this to some centralized config
REQUIRED_NF = "25.04.6"
REQUIRED_JAVA = "24.0.2"


# ------------------------- path helpers -------------------------

def _abs_path(p: str | os.PathLike | None) -> Optional[str]:
    if p is None:
        return None
    return str(Path(os.path.expandvars(str(p))).expanduser().resolve(strict=False))


# ------------------------- version helpers -------------------------

def _parse_version_tuple(v: str) -> Tuple[int, ...]:
    """
    Convert a version string into a tuple of ints for comparison.
    Examples:
      "25.04.6" -> (25, 4, 6)
      "24.0.2"  -> (24, 0, 2)
      "1.8.0_281" -> (1, 8, 0, 281)
    """
    v = v.strip().replace("_", ".")
    parts = re.findall(r"\d+", v)
    return tuple(int(x) for x in parts) if parts else (0,)

def _version_gte(found: str, required: str) -> bool:
    a = _parse_version_tuple(found)
    b = _parse_version_tuple(required)
    # pad to equal length
    n = max(len(a), len(b))
    a += (0,) * (n - len(a))
    b += (0,) * (n - len(b))
    return a >= b

def _get_nextflow_version() -> Optional[str]:
    """
    Runs `nextflow -version` and extracts the first dotted version sequence.
    Typical output includes a line like: "version 25.04.6 build ..."
    """
    try:
        proc = subprocess.run(
            ["nextflow", "-version"],
            check=False, capture_output=True, text=True
        )
    except FileNotFoundError:
        return None
    out = (proc.stdout or "") + (proc.stderr or "")
    m = re.search(r"(\d+\.\d+(?:\.\d+)*)", out)
    return m.group(1) if m else None

def _get_java_version() -> Optional[str]:
    """
    Runs `java -version` and extracts the quoted version string if present,
    falling back to the first dotted sequence.
    Typical output: openjdk version "24.0.2" ...
    """
    try:
        proc = subprocess.run(
            ["java", "-version"],
            check=False, capture_output=True, text=True
        )
    except FileNotFoundError:
        return None
    out = (proc.stdout or "") + (proc.stderr or "")
    m = re.search(r'"(\d+(?:\.\d+)+[^"]*)"', out)  # content inside quotes
    if m:
        return m.group(1)
    m2 = re.search(r"(\d+\.\d+(?:\.\d+)*)", out)   # any dotted version
    return m2.group(1) if m2 else None

def _assert_runtime_versions() -> None:
    nf_ver = _get_nextflow_version()
    if nf_ver is None:
        print("ERROR: Nextflow not found on PATH (need >= {})".format(REQUIRED_NF), file=sys.stderr)
        sys.exit(127)
    if not _version_gte(nf_ver, REQUIRED_NF):
        print(f"ERROR: Nextflow {nf_ver} found, but {REQUIRED_NF}+ is required.", file=sys.stderr)
        sys.exit(2)

    java_ver = _get_java_version()
    if java_ver is None:
        print("ERROR: Java not found on PATH (need >= {})".format(REQUIRED_JAVA), file=sys.stderr)
        sys.exit(127)
    if not _version_gte(java_ver, REQUIRED_JAVA):
        print(f"ERROR: Java {java_ver} found, but {REQUIRED_JAVA}+ is required.", file=sys.stderr)
        sys.exit(2)


# ------------------------- arg parsing -------------------------

def parse_args() -> Tuple[argparse.Namespace, List[str]]:
    p = argparse.ArgumentParser(
        prog="RepeatMasker",
        description="RmAlign front-end that prepares a project dir and calls Nextflow."
    )

    # Inputs we will canonicalize
    p.add_argument("--sequence", required=True, help="Input FASTA")
    p.add_argument("--project_dir", required=True, help="Project work directory")

    # Either species OR a library must be provided (enforced manually)
    p.add_argument("--species", help="Species (Dfam/RepeatMasker species tag)")
    p.add_argument("--lib_file", help="Custom repeat library FASTA")
    p.add_argument("--library", help="Alias for --lib_file")

    args, passthrough = p.parse_known_args()

    # Validate either species or library given
    if not (args.species or args.lib_file or args.library):
        print("ERROR: Either --species OR --lib_file/--library must be provided.", file=sys.stderr)
        sys.exit(2)

    return args, passthrough


# ------------------------- main -------------------------

def main() -> int:
    args, passthrough = parse_args()

    # Normalize key paths
    lib_val = args.lib_file if args.lib_file else args.library
    sequence_abs = _abs_path(args.sequence)
    project_abs  = _abs_path(args.project_dir)
    lib_abs      = _abs_path(lib_val) if lib_val else None

    # Ensure project directory exists
    os.makedirs(project_abs, exist_ok=True)

    # Resolve main.nf relative to this script (absolute), prior to chdir
    script_dir = Path(__file__).resolve().parent
    main_nf = str((script_dir / "main.nf").resolve())

    # Check runtime versions before launching
    _assert_runtime_versions()

    # IMPORTANT: Switch to project directory so NF logs/work are placed there
    os.chdir(project_abs)

    # Build the Nextflow command
    nf_cmd = [
        "nextflow", "run", main_nf,
        "--sequence", sequence_abs,
        "--project_dir", project_abs,
    ]
    if args.species:
        nf_cmd += ["--species", args.species]
    if lib_abs:
        # pipeline expects --lib_file; keep alias logic upstream
        nf_cmd += ["--lib_file", lib_abs]

    # Forward unknown args to Nextflow as-is
    nf_cmd += passthrough

    try:
        proc = subprocess.run(nf_cmd, check=False)
        return proc.returncode
    except FileNotFoundError:
        print("ERROR: nextflow not found on PATH", file=sys.stderr)
        return 127


if __name__ == "__main__":
    raise SystemExit(main())
