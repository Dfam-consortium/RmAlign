# telib/formats/caf.py
from __future__ import annotations

import io
import os
from dataclasses import dataclass
from typing import Iterator, Iterable, Optional, Union, Sequence, TextIO, Type, TypeVar, overload
from telib import PairwiseAlignment

T = TypeVar("T", "CafRecord", PairwiseAlignment)

# -------------------------------------------------------------------
# Public data model
# -------------------------------------------------------------------

@dataclass
class CafRecord:
    """
    Neutral CAF record (strict one-line CSV flavor).

    Field order mirrors the CSV we read/write:
      0  score         (float)
      1  perc_sub      (float)
      2  perc_del      (float)
      3  perc_ins      (float)
      4  qid           (str)
      5  qs            (int, 1-based)
      6  qe            (int, 1-based)
      7  qrem          (Optional[int], leftover bases to Q end)
      8  sid           (str)
      9  [unused]      (empty placeholder)
      10 ss            (int, 1-based)
      11 se            (int, 1-based)
      12 srem          (Optional[int], leftover bases to S end)
      13 orient_c      ("1" for complemented subject; else "0")
      14 [unused]      (empty)
      15 [unused]      (empty)
      16 encoded       (CAF encoded string)
      17 matrix        (Optional[str])
      18.. trailing empties (ignored)
    """
    score: float
    perc_sub: float
    perc_del: float
    perc_ins: float
    qid: str
    qs: int
    qe: int
    qrem: Optional[int]
    sid: str
    ss: int
    se: int
    srem: Optional[int]
    orient_c: bool
    encoded: str
    matrix: Optional[str] = None


# -------------------------------------------------------------------
# Source/Sink helpers (same pattern as crossmatch/bpaf)
# -------------------------------------------------------------------

Source = Union[str, TextIO, Sequence[str]]
Sink = Optional[Union[str, TextIO]]

def _as_lines(source: Source) -> Iterator[str]:
    """
    Yield lines from path/text/file-like/sequence.
    - If 'source' is a path to an existing file → open and iterate.
    - If 'source' is a string but not a file path → treat as whole text.
    - If 'source' has .read → iterate its lines.
    - Else treat as sequence of strings.
    """
    if isinstance(source, str):
        if os.path.exists(source) and os.path.isfile(source):
            with open(source, "r", encoding="utf-8", errors="ignore") as fh:
                for ln in fh:
                    yield ln
        else:
            for ln in io.StringIO(source):
                yield ln
    elif hasattr(source, "read"):
        for ln in source:  # type: ignore[assignment]
            yield ln
    else:
        for ln in source:
            yield ln


# -------------------------------------------------------------------
# CAF encode/decode primitives
# -------------------------------------------------------------------

def _caf_decode_to_aligned(encoded: str, *, reference: str = "query") -> tuple[str, str]:
    """
    Inverse of _caf_build_from_aligned().
    Returns (aligned_query_seq, aligned_target_seq) assuming:
      reference='query' → 'query' is the reference row encoded in -REF- deletions.
      reference='target' → 'target' is the reference row.
    """
    ref_row: list[str] = []
    drv_row: list[str] = []

    i = 0
    n = len(encoded)

    while i < n:
        c = encoded[i]

        if c == '+':
            # +DRVSEG+
            j = encoded.find('+', i + 1)
            if j == -1:
                raise ValueError("CAF: unmatched '+' in insertion block")
            drvseg = encoded[i + 1:j]
            ref_row.extend('-' * len(drvseg))
            drv_row.extend(drvseg)
            i = j + 1
            continue

        if c == '-':
            # -REFSEG-
            j = encoded.find('-', i + 1)
            if j == -1:
                raise ValueError("CAF: unmatched '-' in deletion block")
            refseg = encoded[i + 1:j]
            ref_row.extend(refseg)
            drv_row.extend('-' * len(refseg))
            i = j + 1
            continue

        # Either a match (single base) or a mismatch 'R/D'
        # Peek for slash
        if i + 2 < n and encoded[i + 1] == '/':
            r = encoded[i]          # reference base
            d = encoded[i + 2]      # driver base
            ref_row.append(r)
            drv_row.append(d)
            i += 3
        else:
            # match: single base lives in both rows
            b = encoded[i]
            ref_row.append(b)
            drv_row.append(b)
            i += 1

    # Map rows back to (query, target) according to chosen reference
    if reference == "query":
        q_aln = "".join(ref_row)
        t_aln = "".join(drv_row)
    elif reference == "target":
        t_aln = "".join(ref_row)
        q_aln = "".join(drv_row)
    else:
        raise ValueError("reference must be 'query' or 'target'")

    return q_aln, t_aln


def _caf_build_from_aligned(top: str, bot: str, *, reference: str = "query") -> str:
    """
    Build CAF 'encoded' string from two aligned strings.
    reference='query' → 'top' is the reference row whose bases appear in (-REF-) deletions.
    """
    if len(top) != len(bot):
        raise ValueError("aligned strings must be same length")

    ref = top if reference == "query" else bot
    drv = bot if reference == "query" else top
    print("ref:", ref)

    out: list[str] = []
    i = 0
    n = len(ref)

    while i < n:
        r = ref[i]
        d = drv[i]

        # Non-gap column
        if r != "-" and d != "-":
            if r.upper() == d.upper():
                out.append(r)  # identical: emit one base (keep case of non-ref)
            else:
                out.append(r)
                out.append("/")
                out.append(d)
            i += 1
            continue

        # Insertion w.r.t reference (+DRV+)
        if r == "-" and d != "-":
            j = i
            while j < n and ref[j] == "-" and drv[j] != "-":
                j += 1
            out.append("+")
            out.append(drv[i:j])
            out.append("+")
            i = j
            continue

        # Deletion w.r.t reference (-REF-)
        if r != "-" and d == "-":
            j = i
            while j < n and ref[j] != "-" and drv[j] == "-":
                j += 1
            out.append("-")
            out.append(ref[i:j])
            out.append("-")
            i = j
            continue

        # Double-gap (shouldn't happen in valid pairwise strings); skip
        i += 1

    return "".join(out)


def _parse_record_line(parts: list[str]) -> Optional[CafRecord]:
    if len(parts) < 18:
        ## Hmm...perhaps this should raise instead?
        return None
    try:
        score = float(parts[0]); psub = float(parts[1]); pdel = float(parts[2]); pins = float(parts[3])
        qid = parts[4]; qs = int(parts[5]); qe = int(parts[6])
        qrem = int(parts[7]) if parts[7] else None
        sid = parts[8]
        ss = int(parts[10]); se = int(parts[11])
        srem = int(parts[12]) if parts[12] else None
        orient_c = (parts[13].strip() == "1")
        encoded = parts[16]
        matrix = parts[17] if parts[17] else None
    except Exception:
        return None

    return CafRecord(
        score=score, perc_sub=psub, perc_del=pdel, perc_ins=pins,
        qid=qid, qs=qs, qe=qe, qrem=qrem,
        sid=sid, ss=ss, se=se, srem=srem,
        orient_c=orient_c, encoded=encoded, matrix=matrix
    )


def _record_to_csv_line(r: CafRecord) -> str:
    orient = "1" if r.orient_c else "0"
    matrix = r.matrix or "unknown.scoring_system"
    # Keep placeholders to match historic CSV positions (two empties after sid; three empties at tail)
    return (
        f"{r.score:.2f},{r.perc_sub:.2f},{r.perc_del:.2f},{r.perc_ins:.2f},"
        f"{r.qid},{r.qs},{r.qe},{r.qrem or ''},"
        f"{r.sid},,"
        f"{r.ss},{r.se},{r.srem or ''},"
        f"{orient},,,"
        f"{r.encoded},{matrix},,,\n"
    )


# -------------------------------------------------------------------
# Public helpers matching other formats
# -------------------------------------------------------------------

def caf_records(source: Source) -> Iterator[CafRecord]:
    """
    Stream CafRecord objects from a CAF CSV source (path/text/file-like/sequence).
    """
    for ln in _as_lines(source):
        s = ln.strip()
        if not s or s.startswith("#"):
            continue
        parts = [x.strip() for x in s.split(",")]
        rec = _parse_record_line(parts)
        if rec:
            yield rec


def write_caf_from_rows(rows: Iterable[CafRecord], sink: Union[str, TextIO]) -> None:
    """
    Write CAF CSV lines directly from CafRecord stream to a path or file-like.
    """
    if isinstance(sink, str):
        with open(sink, "wt", encoding="utf-8") as out:
            for r in rows:
                out.write(_record_to_csv_line(r))
        return

    if hasattr(sink, "write"):
        for r in rows:
            sink.write(_record_to_csv_line(r))
        return

    raise TypeError("sink must be a path string or a file-like with .write()")


# -------------------------------------------------------------------
# Public API
# -------------------------------------------------------------------

# --- drop-in replacement: decode() ---
@overload
def decode(source: Source, *, cls: Type["CafRecord"] = ...) -> Iterator["CafRecord"]: ...
@overload
def decode(source: Source, *, cls: Type[PairwiseAlignment]) -> Iterator[PairwiseAlignment]: ...

def decode(source: Source, *, cls: Type[T] = CafRecord) -> Iterator[T]:
    rec_iter = caf_records(source)

    if cls is CafRecord:
        return rec_iter  # type: ignore[return-value]

    if cls is PairwiseAlignment:
        def _gen() -> Iterator[PairwiseAlignment]:
            for r in rec_iter:
                # build the alignment core
                aln = PairwiseAlignment(
                    score=int(r.score),
                    query_id=r.qid,
                    query_start=r.qs,
                    query_end=r.qe,
                    target_id=r.sid,
                    target_start=min(r.ss, r.se),
                    target_end=max(r.ss, r.se),
                    orientation="-" if r.orient_c else "+",
                    matrix_name=r.matrix or "unknown.scoring_system",
                    perc_sub=r.perc_sub,
                    # gap % can be recomputed from strings if needed
                )
                # reconstruct aligned strings from CAF
                # (CAF written by our encoder defaults to reference='query')
                q_aln, t_aln = _caf_decode_to_aligned(r.encoded, reference="query")
                aln.aligned_query_seq = q_aln
                aln.aligned_target_seq = t_aln
                yield aln
        return _gen()  # type: ignore[return-value]

    raise TypeError(f"Unsupported cls={cls!r}; expected CafRecord or PairwiseAlignment")


def encode(
    items: Iterable[Union[PairwiseAlignment, "CafRecord"]],
    *,
    sink: Optional[Union[str, TextIO]] = None,
    reference: str = "query",
) -> str:
    """
    Encode to CAF CSV from either CafRecord or PairwiseAlignment streams.
    Returns emitted text; also writes to sink if provided.
    """
    # If any CafRecord is present, write as-is; otherwise derive CafRecords from PairwiseAlignment
    def _as_records(seq: Iterable[Union[PairwiseAlignment, CafRecord]]) -> Iterable[CafRecord]:
        for x in seq:
            if isinstance(x, CafRecord):
                yield x
            elif isinstance(x, PairwiseAlignment):
                if not x.aligned_query_seq or not x.aligned_target_seq:
                    # skip alignments without strings; CAF needs encoded string
                    continue
                encoded = _caf_build_from_aligned(
                    x.aligned_query_seq, x.aligned_target_seq,
                    reference="query" if reference == "query" else "target",
                )
                # Compute simple %s from strings (like previous writer)
                def _hdr_stats(top: str, bot: str):
                    m = mism = ins = dele = 0
                    for a, b in zip(top, bot):
                        if a == b and a != "-":
                            m += 1
                        elif a == "-" and b != "-":
                            dele += 1
                        elif b == "-" and a != "-":
                            ins += 1
                        elif a != "-" and b != "-":
                            mism += 1
                    ung = m + mism
                    tot = m + mism + ins + dele
                    pdiv = (mism * 100.0 / ung) if ung else 0.0
                    pdel = (dele * 100.0 / tot) if tot else 0.0
                    pins = (ins * 100.0 / tot) if tot else 0.0
                    return pdiv, pdel, pins

                pdiv, pdel, pins = _hdr_stats(x.aligned_query_seq, x.aligned_target_seq)

                yield CafRecord(
                    score=float(x.score),
                    perc_sub=pdiv,
                    perc_del=pdel,
                    perc_ins=pins,
                    qid=x.query_id,
                    qs=x.query_start,
                    qe=x.query_end,
                    qrem=(x.query_len - x.query_end) if x.query_len else None,
                    sid=x.target_id,
                    ss=min(x.target_start, x.target_end),
                    se=max(x.target_start, x.target_end),
                    srem=(x.target_len - x.target_end) if x.target_len else None,
                    orient_c=(x.orientation == "-"),
                    encoded=encoded,
                    matrix=x.matrix_name or "unknown.scoring_system",
                )
            else:
                raise TypeError("encode() items must be PairwiseAlignment or CafRecord")

    # Write or return text
    if sink is None:
        buf = io.StringIO()
        write_caf_from_rows(_as_records(items), buf)  # type: ignore[arg-type]
        return buf.getvalue()

    if isinstance(sink, str):
        write_caf_from_rows(_as_records(items), sink)  # type: ignore[arg-type]
        with open(sink, "rt", encoding="utf-8") as f:
            return f.read()

    if hasattr(sink, "write"):
        write_caf_from_rows(_as_records(items), sink)  # type: ignore[arg-type]
        return ""

    raise TypeError("sink must be a path string, a file-like with .write, or None")

